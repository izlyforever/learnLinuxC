## gdb

> 想要写出Bug-free的程序是非常不容易的

在编译时要加上-g选项，生成的可执行文件才能用gdb进行源码级调试：

-g选项的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，所以在调试时必须保证gdb能找到源文件。gdb提供一个类似Shell的命令行环境，上面的(gdb)就是提示符，在这个提示符下输入help可以查看命令的类别

然后 gdb a.out 之后 `set args` 在 start 就可以传入参数了，其他的很多都可以 help 然后就知道怎么搞了

> 当然了我们完全可以用 vscode + codelldb 插件完成，但是 gdb 才更本质，可选内容也更丰富

### gdb基本命令1

|           命令          |       描述         |
|:-----------------------:|:----------------------------------------------:|
| backtrace（或bt）       | 查看各级函数调用及参数                                                           |
| finish                  | 连续运行到当前函数返回为止，然后停下来等待命令                                   |
| frame（或f） 帧编号     | 选择栈帧                                                                         |
| info（或i） locals      | 查看当前栈帧局部变量的值                                                         |
| list（或l）             | 列出源代码，接着上次的位置往下列，每次列10行                                     |
| list 行号               | 列出从第几行开始的源代码                                                         |
| list 函数名             | 列出某个函数的源代码                                                             |
| next（或n）             | 执行下一行语句                                                                   |
| print（或p）            | 打印表达式的值，通过表达式可以修改变量的值或者调用函数                           |
| quit（或q）             | 退出gdb调试环境                                                                  |
| set var                 | 修改变量的值                                                                     |
| start                   | 开始执行程序，停在main函数第一行语句前面等待命令                                 |
| step（或s）             | 执行下一行语句，如果有函数调用则进入到函数中                                     |
| watch                   | 设置观察点                                                                       |
| info（或i） watchpoints | 查看当前设置了哪些观察点                                                         |
| x                       | 从某个位置开始打印存储单元的内容，全部当成字节来看，而不区分哪个字节属于哪个变量 |
| layout                  | layout src 就可以一边 debug 一边看代码 |

