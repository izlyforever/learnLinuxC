## 指针

首先指针本身的长度只和机器是 32 位还是 64 位有关（**以下都假设 64 位**）

`void* p` 的意思是它取址的时候长度为 0，所以此时 `*p` 是没有意义的（编译会报错），而 `void** q` 而言 q 的取址长度为 8，所以 `*p` 是没问题的

由于 C 中没有引用，所以指针十分常见。**其实引用有时候也没有那么好，调用者就容易看不出来自己会不会被改变**

> 返回一个局部变量的 引用/指针 是愚蠢的

## 回调函数

可以用回调函数+`void*‵就可以作类似泛型的事情，例如 qsort函数的实现，可以对一组任意类型的对象做快速排序

## 可变参数

要处理可变参数，需要用C到标准库的va_list类型和va_start、va_arg、va_end宏，这些定义在stdarg.h头文件中。这些宏是如何取出可变参数的呢？我们首先对照反汇编分析在调用 myprintf 函数时这些参数的内存布局。

有些 stdarg.h 这个头文件中的内部宏定义_Bnd(X, bnd)将类型或变量X的长度对齐到bnd+1字节的整数倍，例如_Bnd(char, 3U)的值是4，_Bnd(int, 3U)也是4。因此要求char型的可变参数必须按int型来取。

printf函数根据第一个参数（格式化字符串）来确定后面有几个参数，分别是什么类型。保证参数的类型、个数与格式化字符串的描述相匹配是调用者的责任，实现者只管按格式化字符串的描述从栈上取数据，如果调用者传递的参数类型或个数不正确，实现者是没有办法避免错误的。还有一种方法可以确定可变参数的个数，就是在参数列表的末尾传一个Sentinel，例如NULL。execl(3)就采用这种方法确定参数的个数。下面实现一个printlist函数，可以打印若干个传入的字符串。



