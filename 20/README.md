## 链接详解

简单的多文件编译实例见 mulfiles 目录 `gcc main.c stack.c` 和 `gcc stack.c main.c` 得到的二进制是本质不同的（一些符号的顺序会不同）



为什么编译器在处理函数调用代码时需要有函数原型？因为必须知道参数的类型和个数以及返回值的类型才知道生成什么样的指令。为什么隐式声明靠不住呢？因为隐式声明是从函数调用代码推导而来的，而事实上函数定义的形参类型可能跟函数调用代码传的实参类型并不一致，如果函数定义带有可变参数（例如printf），那么从函数调用代码也看不出来这个函数带有可变参数，另外，从函数调用代码也看不出来返回值应该是什么类型，所以隐式声明只能规定返回值都是int型的。既然隐式声明靠不住，那编译器为什么不自己去找函数定义，而非要让我们在调用之前写函数原型呢？因为编译器往往不知道去哪里找函数定义，像上面的例子，我让编译器编译main.c，而这几个函数的定义却在stack.c里，编译器又怎么会知道呢？所以编译器只能通过隐式声明来猜测函数原型，这种猜测往往会出错，但在比较简单的情况下还算可用，比如上一节的例子这么编译过去了也能得到正确结果。

> 为什么变量可以需要 extern 而函数不需要呢？因为函数的 extern 可以省略不写。所以所谓的 `.h` 文件是定义本质上是 extern 声明。而变量一般是 `.c` 中定义，`.h` 中使用 extern

> 注意 include 只有一次是一个编译单元只有一次，而不是整个模块只有一次

动态库和静态库的例子分别在 dynamic 和 staitc

## 虚拟内存

我们知道操作系统利用体系结构提供的VA到PA的转换机制实现虚拟内存管理。
x86平台的虚拟地址空间是0x0000 0000~0xffff ffff，大致上前3GB（0x0000 0000~0xbfff ffff）是用户空间，后1GB（0xc000 0000~0xffff ffff）是内核空间，在这里得到了印证。0x0804 8000-0x080f 4000是从/bin/bash加载到内存的，访问权限为r-x，表示Text Segment，包含.text段、.rodata段、.plt段等。0x080f 4000-0x080f 9000也是从/bin/bash加载到内存的，访问权限为rw-，表示Data Segment，包含.data段、.bss段等。

- 虚拟内存管理可以控制物理内存的访问权限。
- 虚拟内存管理最主要的作用是让每个进程有独立的地址空间。
- VA到PA的映射会给分配和释放内存带来方便，物理地址不连续的几块内存可以映射成虚拟地址连续的一块内存。比如要用malloc分配一块很大的内存空间，虽然有足够多的空闲物理内存，却没有足够大的连续空闲内存，这时就可以分配多个不连续的物理页面而映射到连续的虚拟地址范围。
- 个系统如果同时运行着很多进程，为各进程分配的内存之和可能会大于实际可用的物理内存，虚拟内存管理使得这种情况下各进程仍然能够正常运行。因为各进程分配的只不过是虚拟内存的页面，这些页面的数据可以映射到物理页面，也可以临时保存到磁盘上而不占用物理页面，在磁盘上临时保存虚拟内存页面的可能是一个磁盘分区，也可能是一个磁盘文件，称为交换设备（Swap Device）。

